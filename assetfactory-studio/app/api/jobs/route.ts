\nimport { NextRequest, NextResponse } from \'next/server\';\nimport { db } from \'../../../lib/firebase\';\nimport { authenticateAndAuthorize, checkSubscription } from \'../../../lib/auth\';\nimport { logger } from \'../../../lib/logger\';\nimport * as admin from \'firebase-admin\';\n\n// --- Durable Rate Limiting (Firestore) ---\nconst RATE_LIMIT_WINDOW_MS = 15 * 60 * 1000; // 15 minutes\nconst MAX_REQUESTS_PER_WINDOW = 100;       // 100 requests per 15 minutes per user\n\nasync function isRateLimited(ip: string): Promise<boolean> {\n    const now = Date.now();\n    const rateLimitRef = db.collection(\'rate-limits\').doc(ip);\n\n    try {\n        let isLimited = false;\n        await db.runTransaction(async (transaction) => {\n            const doc = await transaction.get(rateLimitRef);\n            if (!doc.exists) {\n                transaction.set(rateLimitRef, { timestamps: [now] });\n                return;\n            }\n\n            const data = doc.data();\n            const timestamps = (data?.timestamps || []).filter(\n                (ts: number) => now - ts < RATE_LIMIT_WINDOW_MS\n            );\n\n            if (timestamps.length >= MAX_REQUESTS_PER_WINDOW) {\n                isLimited = true;\n                return; \n            }\n\n            timestamps.push(now);\n            transaction.update(rateLimitRef, { timestamps });\n        });\n        return isLimited;\n    } catch (error) {\n        logger.error(\'Rate limiting check failed.\', { ip, error: (error as Error).message });\n        return true; // Failsafe: Block request if rate limiting fails.\n    }\n}\n\n// --- Usage Limit Enforcement ---\nasync function isUsageLimitExceeded(tenantId: string): Promise<boolean> {\n    try {\n        const tenantRef = db.collection(\'tenants\').doc(tenantId);\n        const tenantDoc = await tenantRef.get();\n\n        if (!tenantDoc.exists) {\n            logger.warn(\'Tenant document not found for usage check.\', { tenantId });\n            return true;\n        }\n\n        const tenantData = tenantDoc.data();\n        const monthlyJobLimit = tenantData?.monthlyJobLimit || 100;\n\n        const now = new Date();\n        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();\n\n        const jobsSnapshot = await db.collection(\'jobs\')\n            .where(\'tenantId\', \'==\', tenantId)\n            .where(\'createdAt\', \'>=\', startOfMonth)\n            .get();\n\n        const jobsThisMonth = jobsSnapshot.size;\n\n        if (jobsThisMonth >= monthlyJobLimit) {\n            logger.warn(\'Monthly job limit exceeded for tenant.\', { tenantId, jobsThisMonth, monthlyJobLimit });\n            return true;\n        }\n\n        return false;\n    } catch (error) {\n        logger.error(\'Failed to check usage limits.\', { tenantId, error: (error as Error).message });\n        return true;\n    }\n}\n\n// --- API Endpoint: POST /api/jobs ---\nexport async function POST(req: NextRequest) {\n    const ip = req.headers.get(\'x-forwarded-for\') ?? \'127.0.0.1\';\n    try {\n        if (await isRateLimited(ip)) { // USE DURABLE RATE LIMITER\n            logger.warn(\`Rate limit exceeded for IP: ${ip}\`, { ip });\n            return NextResponse.json({ error: \'Too Many Requests\' }, { status: 429 });\n        }\n\n        const { tenantId } = await authenticateAndAuthorize(req);\n        if (!tenantId) {\n            return NextResponse.json({ error: \'Forbidden\' }, { status: 403 });\n        }\n\n        const isSubscribed = await checkSubscription(tenantId);\n        if (!isSubscribed) {\n            logger.info(\'Rejecting job for unsubscribed tenant\', { tenantId });\n            return NextResponse.json({ error: \'Active subscription required.\' }, { status: 403 });\n        }\n\n        if (await isUsageLimitExceeded(tenantId)) {\n            return NextResponse.json({ error: \'Monthly job quota exceeded.\' }, { status: 429 });\n        }\n\n        const inputData = await req.json();\n\n        if (!inputData.prompt || typeof inputData.prompt !== \'string\') {\n            return NextResponse.json({ error: \'Invalid input: \"prompt\" is required and must be a string.\' }, { status: 400 });\n        }\n\n        if (inputData.clientRequestId) {\n            const existingJobs = await db.collection(\'jobs\').where(\'tenantId\', \'==\', tenantId).where(\'input.clientRequestId\', \'==\', inputData.clientRequestId).limit(1).get();\n            if (!existingJobs.empty) {\n                const existingJob = existingJobs.docs[0];\n                logger.info(`Idempotent request: Found existing job for clientRequestId.`, { tenantId, jobId: existingJob.id, clientRequestId: inputData.clientRequestId });\n                return NextResponse.json({ message: \'Job already exists\', jobId: existingJob.id, status: existingJob.data().status }, { status: 200 });\n            }\n        }\n        \n        const newJob = {\n            tenantId,\n            status: \"queued\",\n            createdAt: new Date().toISOString(),\n            input: inputData,\n            retryCount: 0,\n            seed: inputData.seed || Math.floor(Math.random() * 1000000000),\n        };\n\n        const jobRef = await db.collection(\'jobs\').add(newJob);\n\n        logger.info(`Job submitted successfully.`, { tenantId, jobId: jobRef.id });\n\n        return NextResponse.json({ message: \'Job submitted successfully\', jobId: jobRef.id, status: \'queued\' }, { status: 202 });\n\n    } catch (error: any) {\n        logger.error(\'Error submitting job\', { error: error.message, ip });\n        if (error.message.includes(\'Authorization\') || error.message.includes(\'Forbidden\')) {\n            return NextResponse.json({ error: error.message }, { status: 401 });\n        }\n        return NextResponse.json({ error: \'Internal Server Error\' }, { status: 500 });\n    }\n}\n\n// --- API Endpoint: GET /api/jobs ---\nexport async function GET(req: NextRequest) {\n    try {\n        const { tenantId } = await authenticateAndAuthorize(req);\n        if (!tenantId) {\n            return NextResponse.json({ error: \'Forbidden\' }, { status: 403 });\n        }\n        \n        const { searchParams } = new URL(req.url);\n        const jobId = searchParams.get(\'jobId\');\n        \n        if (jobId) {\n            const jobDoc = await db.collection(\'jobs\').doc(jobId).get();\n            if (!jobDoc.exists || jobDoc.data()?.tenantId !== tenantId) {\n                return NextResponse.json({ error: \"Job not found\" }, { status: 404 });\n            }\n            return NextResponse.json({ id: jobDoc.id, ...jobDoc.data() }, { status: 200 });\n        } else {\n             const jobsSnapshot = await db.collection(\'jobs\').where(\'tenantId\', \'==\', tenantId).orderBy(\'createdAt\', \'desc\').limit(25).get();\n            if (jobsSnapshot.empty) {\n                return NextResponse.json([], { status: 200 });\n            }\n            const jobs = jobsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n            return NextResponse.json(jobs, { status: 200 });\n        }\n    } catch (error: any) {\n        logger.error(\'Error fetching jobs\', { error: error.message });\n         if (error.message.includes(\'Authorization\') || error.message.includes(\'Forbidden\')) {\n            return NextResponse.json({ error: error.message }, { status: 401 });\n        }\n        return NextResponse.json({ error: \'Internal Server Error\' }, { status: 500 });\n    }\n}\n